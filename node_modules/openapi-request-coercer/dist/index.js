"use strict";
exports.__esModule = true;
var ts_log_1 = require("ts-log");
var OpenAPIRequestCoercer = /** @class */ (function () {
    function OpenAPIRequestCoercer(args) {
        var loggingKey = args && args.loggingKey ? args.loggingKey + ": " : '';
        if (!args) {
            throw new Error(loggingKey + "missing args argument");
        }
        var logger = args.logger || ts_log_1.dummyLogger;
        if (!Array.isArray(args.parameters)) {
            throw new Error(loggingKey + "args.parameters must be an Array");
        }
        var extensionBase = args && args.extensionBase ? args.extensionBase : 'x-openapi-coercion';
        var strictExtensionName = extensionBase + "-strict";
        var enableObjectCoercion = !!args.enableObjectCoercion;
        this.coerceHeaders = buildCoercer({
            params: args.parameters,
            property: 'header',
            isHeaders: true,
            logger: logger,
            loggingKey: loggingKey,
            strictExtensionName: strictExtensionName,
            enableObjectCoercion: enableObjectCoercion
        });
        this.coerceParams = buildCoercer({
            params: args.parameters,
            property: 'path',
            isHeaders: false,
            logger: logger,
            loggingKey: loggingKey,
            strictExtensionName: strictExtensionName,
            enableObjectCoercion: enableObjectCoercion
        });
        this.coerceQuery = buildCoercer({
            params: args.parameters,
            property: 'query',
            isHeaders: false,
            logger: logger,
            loggingKey: loggingKey,
            strictExtensionName: strictExtensionName,
            enableObjectCoercion: enableObjectCoercion
        });
        this.coerceFormData = buildCoercer({
            params: args.parameters,
            property: 'formData',
            isHeaders: false,
            logger: logger,
            loggingKey: loggingKey,
            strictExtensionName: strictExtensionName,
            enableObjectCoercion: enableObjectCoercion
        });
    }
    OpenAPIRequestCoercer.prototype.coerce = function (request) {
        if (request.headers && this.coerceHeaders) {
            this.coerceHeaders(request.headers);
        }
        if (request.params && this.coerceParams) {
            this.coerceParams(request.params);
        }
        if (request.query && this.coerceQuery) {
            this.coerceQuery(request.query);
        }
        if (request.body && this.coerceFormData) {
            this.coerceFormData(request.body);
        }
    };
    return OpenAPIRequestCoercer;
}());
exports["default"] = OpenAPIRequestCoercer;
var OBJECT_FORMAT_COERCER = {
    "default": function (input) {
        return JSON.parse(input);
    }
    // other formats
};
var COERCION_STRATEGIES = {
    array: function (itemCoercer, collectionFormat, input) {
        if (!Array.isArray(input)) {
            var sep = pathsep(collectionFormat || 'csv');
            input = input.split(sep);
        }
        input.forEach(function (v, i) {
            input[i] = itemCoercer(v);
        });
        return input;
    },
    object: function (format, input) {
        return (OBJECT_FORMAT_COERCER[format] || OBJECT_FORMAT_COERCER["default"])(input);
    },
    boolean: function (input) {
        if (typeof input === 'boolean') {
            return input;
        }
        if (input === 'false') {
            return false;
        }
        else {
            return true;
        }
    },
    integer: function (input) {
        var result = Math.floor(Number(input));
        return isNaN(result) ? input : result;
    },
    number: function (input) {
        var result = Number(input);
        return isNaN(result) ? input : result;
    },
    string: function (input) { return String(input); }
};
var STRICT_COERCION_STRATEGIES = {
    boolean: function (input) {
        if (typeof input === 'boolean') {
            return input;
        }
        if (input.toLowerCase() === 'false') {
            return false;
        }
        else if (input.toLowerCase() === 'true') {
            return true;
        }
        else {
            return null;
        }
    }
};
function buildCoercer(args) {
    var l = args.isHeaders
        ? function (name) {
            return name.toLowerCase();
        }
        : function (name) {
            return name;
        };
    var coercion;
    if (args.params.length) {
        var coercers_1 = {};
        args.params.filter(byLocation(args.property)).forEach(function (param) {
            // OpenAPI (Swagger) 2.0 has type and format information as direct properties
            // of the param object. OpenAPI 3.0 has type and format information in a
            // schema object property. Use a schema value to normalize the change across
            // both versions so coercer works properly.
            var schema = param.schema || param;
            var name = param.name;
            var type = schema.type;
            var strict = !!param[args.strictExtensionName];
            var coercer;
            var itemCoercer;
            if (type === 'array') {
                var disableCoercer = void 0;
                if (!schema.items) {
                    throw new Error(args.loggingKey + "items is a required property with type array");
                }
                if (schema.items.type === 'array' ||
                    (schema.items.schema && schema.items.schema.type === 'array')) {
                    throw new Error(args.loggingKey + "nested arrays are not allowed (items was of type array)");
                }
                var itemsType = schema.items.schema && schema.items.schema.type
                    ? schema.items.schema.type
                    : schema.items.type;
                itemCoercer = getCoercer(itemsType, strict, args.logger, args.loggingKey);
                if (itemsType === 'object') {
                    if (!args.enableObjectCoercion) {
                        disableCoercer = true;
                    }
                    else {
                        var itemsFormat = schema.items.schema
                            ? schema.items.schema.format
                            : schema.format;
                        itemCoercer = itemCoercer.bind(null, itemsFormat);
                    }
                }
                if (!disableCoercer) {
                    var collectionFormat = param.collectionFormat;
                    // OpenAPI 3.0 has replaced collectionFormat with a style property
                    // https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#style-values
                    if (param.style) {
                        if (param.style === 'form' && param["in"] === 'query') {
                            collectionFormat = param.explode ? 'multi' : 'csv';
                        }
                        else if (param.style === 'simple' &&
                            (param["in"] === 'path' || param["in"] === 'header')) {
                            collectionFormat = 'csv';
                        }
                        else if (param.style === 'spaceDelimited' &&
                            param["in"] === 'query') {
                            collectionFormat = 'ssv';
                        }
                        else if (param.style === 'pipeDelimited' &&
                            param["in"] === 'query') {
                            collectionFormat = 'pipes';
                        }
                    }
                    coercer = COERCION_STRATEGIES.array.bind(null, itemCoercer, collectionFormat);
                }
            }
            else if (type === 'object') {
                if (args.enableObjectCoercion) {
                    coercer = getCoercer(schema.type, strict, args.logger, args.loggingKey).bind(null, schema.format);
                }
            }
            else {
                coercer = getCoercer(schema.type, strict, args.logger, args.loggingKey);
            }
            if (coercer) {
                coercers_1[l(name)] = coercer;
            }
        });
        coercion = function (obj) {
            for (var paramName in obj) {
                if (paramName in coercers_1) {
                    obj[paramName] = coercers_1[paramName](obj[paramName]);
                }
            }
        };
    }
    return coercion;
}
function byLocation(location) {
    return function (param) { return param["in"] === location; };
}
function identityCoercer(input) {
    return input;
}
function getCoercer(type, strict, logger, loggingKey) {
    var strategy;
    if (strict) {
        strategy = STRICT_COERCION_STRATEGIES[type];
    }
    if (!strategy) {
        strategy = COERCION_STRATEGIES[type];
    }
    if (strategy === undefined) {
        var msg = type === undefined
            ? 'No type has been defined'
            : "No proper coercion strategy has been found for type '" + type + "'";
        logger.warn(loggingKey, msg + ". A default 'identity' strategy has been set.");
        strategy = identityCoercer;
    }
    return strategy;
}
function pathsep(format) {
    switch (format) {
        case 'csv':
            return ',';
        case 'ssv':
            return ' ';
        case 'tsv':
            return '\t';
        case 'pipes':
            return '|';
    }
}
//# sourceMappingURL=index.js.map